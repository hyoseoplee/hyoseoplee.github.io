<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>단어카드</title>
  <meta name="theme-color" content="#111827" />
  <link rel="manifest" href="data:application/manifest+json,{&quot;name&quot;:&quot;단어카드&quot;,&quot;short_name&quot;:&quot;단어카드&quot;,&quot;display&quot;:&quot;standalone&quot;,&quot;background_color&quot;:&quot;#ffffff&quot;,&quot;theme_color&quot;:&quot;#111827&quot;}" />
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { -webkit-tap-highlight-color: transparent; }
    .icon-btn { line-height: 1; }
  </style>
</head>
<body class="bg-gray-50">
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
    const { useEffect, useMemo, useRef, useState } = React;

    const LS_KEYS = {
      WORDS: "vocab_words_v3",
      STATS: "vocab_stats_v3",
      LOGS:  "vocab_logs_v1",
      CONFIG: "vocab_config_v2", // includes mode
    };

    function uid() {
      return Math.random().toString(36).slice(2) + Date.now().toString(36);
    }
    function loadJSON(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : fallback;
      } catch {
        return fallback;
      }
    }
    function saveJSON(key, value) {
      localStorage.setItem(key, JSON.stringify(value));
    }

    // Simple debounce
    function debounce(fn, wait=800) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    function wordWeight(w) {
      if (!w.timesSeen) return 6;
      const knownRate = (w.timesKnown || 0) / (w.timesSeen || 1);
      const weight = 1 + 4 * (1 - knownRate);
      const recencyBoost = w.lastSeen ? Math.min(2, (Date.now() - w.lastSeen) / (1000 * 60 * 60 * 24 * 7)) : 1;
      return Math.max(1, weight * (1 + 0.15 * recencyBoost));
    }

    function weightedSample(items, k) {
      if (items.length === 0) return [];
      const withWeight = items.map((x) => ({ ...x }));
      const result = [];
      let pool = [...withWeight];
      while (result.length < k) {
        const sum = pool.reduce((s, p) => s + p.weight, 0);
        const r = Math.random() * sum;
        let acc = 0;
        let pickedIndex = 0;
        for (let i = 0; i < pool.length; i++) {
          acc += pool[i].weight;
          if (r <= acc) { pickedIndex = i; break; }
        }
        result.push(pool[pickedIndex].item);
        if (withWeight.length >= k) {
          pool.splice(pickedIndex, 1);
          if (pool.length === 0) pool = [...withWeight];
        }
        if (withWeight.length < k && result.length >= withWeight.length * 2) break;
      }
      while (result.length < k && withWeight.length > 0) {
        result.push(withWeight[Math.floor(Math.random() * withWeight.length)].item);
      }
      return result.slice(0, k);
    }

    // ---- Cloud sync via GitHub Gist (optional) ----
    async function gistCreateOrUpdate({ token, gistId, filename, content }) {
      const headers = {
        "Content-Type": "application/json",
        "Accept": "application/vnd.github+json",
        "Authorization": `Bearer ${token}`,
      };
      const body = { files: { [filename]: { content } } };
      const endpoint = gistId ? `https://api.github.com/gists/${gistId}` : "https://api.github.com/gists";
      const method = gistId ? "PATCH" : "POST";
      if (!gistId) {
        body.description = "vocab-mobile data (words, stats, logs)";
        body.public = false;
      }
      const res = await fetch(endpoint, { method, headers, body: JSON.stringify(body) });
      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`Gist 저장 실패: ${res.status} ${txt}`);
      }
      return await res.json();
    }
    async function gistLoad({ token, gistId, filename }) {
      const headers = {
        "Accept": "application/vnd.github+json",
        "Authorization": `Bearer ${token}`,
      };
      const res = await fetch(`https://api.github.com/gists/${gistId}`, { headers });
      if (!res.ok) {
        const txt = await res.text();
        throw new Error(`Gist 불러오기 실패: ${res.status} ${txt}`);
      }
      const data = await res.json();
      const file = data.files && data.files[filename];
      if (!file) throw new Error("해당 파일명을 가진 항목이 Gist에 없습니다.");
      return file.content;
    }

    // ---- TTS (Japanese) ----
    function speakJa(text) {
      try {
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "ja-JP";
        const voices = window.speechSynthesis.getVoices();
        const ja = voices.find(v => v.lang && v.lang.toLowerCase().startsWith("ja"));
        if (ja) u.voice = ja;
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
      } catch(e) {
        alert("이 브라우저에서 음성 합성이 지원되지 않습니다.");
      }
    }

    function App() {
      const [tab, setTab] = useState("study");
      const [mode, setMode] = useState(loadJSON(LS_KEYS.CONFIG, {}).mode || "ja2ko"); // ja2ko or ko2ja
      const [words, setWords] = useState(loadJSON(LS_KEYS.WORDS, []));
      const [stats, setStats] = useState(loadJSON(LS_KEYS.STATS, {
        sessions:0, reviews:0, correct:0, incorrect:0, history:[],
        perMode: { ja2ko: { reviews:0, correct:0 }, ko2ja: { reviews:0, correct:0 } },
      }));
      const [logs, setLogs] = useState(loadJSON(LS_KEYS.LOGS, [])); // [{id, ts, mode, total, correct, items:[{id,jp,ko,correct}]}]
      const [config, setConfig] = useState(() => {
        const prev = loadJSON(LS_KEYS.CONFIG, {
          gistToken: "", gistId: "", autoSync: false, filename: "vocab_data.json", mode: "ja2ko"
        });
        return { ...prev, mode: prev.mode || "ja2ko" };
      });

      useEffect(() => saveJSON(LS_KEYS.WORDS, words), [words]);
      useEffect(() => saveJSON(LS_KEYS.STATS, stats), [stats]);
      useEffect(() => saveJSON(LS_KEYS.LOGS, logs), [logs]);
      useEffect(() => { saveJSON(LS_KEYS.CONFIG, config); }, [config]);
      useEffect(() => { setConfig(prev => ({ ...prev, mode })); }, [mode]);

      // Auto sync debounce
      const debouncedAutoSave = useMemo(() => debounce(async () => {
        if (config.autoSync && config.gistToken && config.filename) {
          try {
            const payload = JSON.stringify({ words, stats, logs }, null, 2);
            const resp = await gistCreateOrUpdate({
              token: config.gistToken,
              gistId: config.gistId || undefined,
              filename: config.filename,
              content: payload,
            });
            if (!config.gistId && resp.id) {
              setConfig(prev => ({ ...prev, gistId: resp.id }));
            }
          } catch (err) {
            console.error(err);
          }
        }
      }, 1200), [config, words, stats, logs]);

      useEffect(() => {
        debouncedAutoSave();
      }, [words, stats, logs, config.autoSync]);

      const [session, setSession] = useState({ active:false, queue:[], index:0, results:[] });
      const [showBack, setShowBack] = useState(false);

      const startSession = () => {
        if (words.length === 0) {
          alert("먼저 단어를 추가해 주세요.");
          setTab("words"); return;
        }
        const weighted = words.map((w) => ({ item: w, weight: wordWeight(w) }));
        const queue = weightedSample(weighted, 30);
        setSession({ active: true, queue, index: 0, results: [] });
        setShowBack(false);
      };

      const current = session.active ? session.queue[session.index] : null;

      const recordAnswer = (isKnown) => {
        if (!current) return;
        setWords((prev) => prev.map((w) => {
          if (w.id !== current.id) return w;
          const upd = { ...w };
          upd.timesSeen = (upd.timesSeen || 0) + 1;
          if (isKnown) { upd.timesKnown = (upd.timesKnown || 0) + 1; upd.streakKnown = (upd.streakKnown || 0) + 1; }
          else { upd.timesUnknown = (upd.timesUnknown || 0) + 1; upd.streakKnown = 0; }
          upd.lastSeen = Date.now();
          return upd;
        }));
        setSession((s) => ({ ...s, results: [...s.results, { id: current.id, correct: isKnown, jp: current.jp, ko: current.ko }], index: Math.min(s.index + 1, s.queue.length) }));
        setShowBack(false);
      };

      const finishSession = useMemo(() => session.active && session.index >= session.queue.length, [session]);

      useEffect(() => {
        if (finishSession) {
          const total = session.results.length;
          const correct = session.results.filter(r => r.correct).length;
          const incorrect = total - correct;
          setStats((prev) => ({
            ...prev,
            sessions: prev.sessions + 1,
            reviews: prev.reviews + total,
            correct: prev.correct + correct,
            incorrect: prev.incorrect + incorrect,
            perMode: {
              ...prev.perMode,
              [mode]: {
                reviews: (prev.perMode?.[mode]?.reviews || 0) + total,
                correct: (prev.perMode?.[mode]?.correct || 0) + correct,
              }
            },
            history: [...prev.history.slice(-49), { ts: Date.now(), total, correct, mode }],
          }));
          setLogs((prev) => [...prev, { id: uid(), ts: Date.now(), mode, total, correct, items: session.results.map(r=>({ id: r.id, jp: r.jp, ko: r.ko, correct: r.correct })) }]);
        }
      }, [finishSession]);

      const missedWordIds = useMemo(() => new Set(session.results.filter(r => !r.correct).map(r => r.id)), [session.results]);
      const missedWords = useMemo(() => words.filter(w => missedWordIds.has(w.id)), [words, missedWordIds]);

      const restartWithMissed = () => {
        const candidates = missedWords.length ? missedWords : words;
        const weighted = candidates.map((w) => ({ item: w, weight: missedWords.length ? 6 : wordWeight(w) }));
        const queue = weightedSample(weighted, Math.min(30, Math.max(10, candidates.length)));
        setSession({ active: true, queue, index: 0, results: [] });
        setShowBack(false);
        setTab("study");
      };

      const [jp, setJp] = useState("");
      const [ko, setKo] = useState("");

      const addWord = () => {
        if (!jp.trim() || !ko.trim()) return;
        const newWord = { id: uid(), jp: jp.trim(), ko: ko.trim(), addedAt: Date.now(), timesSeen:0, timesKnown:0, timesUnknown:0, lastSeen:null, streakKnown:0 };
        setWords((prev) => [newWord, ...prev]);
        setJp(""); setKo("");
      };

      const bulkRef = React.useRef(null);
      const addBulk = () => {
        const textarea = bulkRef.current;
        if (!textarea) return;
        const lines = textarea.value.split(/\n+/).map(l => l.trim()).filter(Boolean);
        if (lines.length === 0) return;
        const newItems = lines.map((line) => {
          const [j, k] = line.split(/[,\t|]/);
          return { id: uid(), jp: (j||"").trim(), ko: (k||"").trim(), addedAt: Date.now(), timesSeen:0, timesKnown:0, timesUnknown:0, lastSeen:null, streakKnown:0 };
        }).filter(w => w.jp && w.ko);
        if (newItems.length === 0) return;
        setWords((prev) => [...newItems, ...prev]);
        textarea.value = "";
      };

      const removeWord = (id) => setWords((prev) => prev.filter((w) => w.id !== id));

      const resetAll = () => {
        if (!confirm("모든 단어, 통계, 로그를 초기화하시겠습니까?")) return;
        setWords([]);
        setStats({ sessions:0, reviews:0, correct:0, incorrect:0, history:[], perMode:{ ja2ko:{reviews:0,correct:0}, ko2ja:{reviews:0,correct:0} } });
        setLogs([]);
        setSession({ active: false, queue: [], index: 0, results: [] });
        setShowBack(false);
      };

      const accuracyTotal = stats.reviews ? Math.round((stats.correct / stats.reviews) * 100) : 0;
      const accuracyJa2Ko = stats.perMode.ja2ko.reviews ? Math.round((stats.perMode.ja2ko.correct / stats.perMode.ja2ko.reviews)*100) : 0;
      const accuracyKo2Ja = stats.perMode.ko2ja.reviews ? Math.round((stats.perMode.ko2ja.correct / stats.perMode.ko2ja.reviews)*100) : 0;
      const knownCount = words.filter(w => w.timesSeen > 0 && (w.timesKnown / w.timesSeen) >= 0.8).length;
      const weakCount = words.filter(w => w.timesSeen > 0 && (w.timesKnown / w.timesSeen) < 0.5).length;

      // ---- Cloud sync handlers ----
      const saveToGist = async () => {
        if (!config.gistToken) return alert("토큰을 입력해 주세요.");
        try {
          const payload = JSON.stringify({ words, stats, logs }, null, 2);
          const resp = await gistCreateOrUpdate({
            token: config.gistToken,
            gistId: config.gistId || undefined,
            filename: config.filename,
            content: payload,
          });
          if (!config.gistId && resp.id) {
            setConfig(prev => ({ ...prev, gistId: resp.id }));
          }
          alert("Gist에 저장했습니다.");
        } catch (e) {
          alert(e.message);
        }
      };
      const loadFromGist = async () => {
        if (!config.gistToken || !config.gistId) return alert("토큰과 Gist ID를 입력해 주세요.");
        try {
          const txt = await gistLoad({
            token: config.gistToken,
            gistId: config.gistId,
            filename: config.filename,
          });
          const data = JSON.parse(txt);
          if (Array.isArray(data.words)) setWords(data.words);
          if (data.stats) setStats(data.stats);
          if (Array.isArray(data.logs)) setLogs(data.logs);
          alert("Gist에서 불러왔습니다.");
        } catch (e) {
          alert(e.message);
        }
      };
      const createNewGist = async () => {
        if (!config.gistToken) return alert("토큰을 입력해 주세요.");
        try {
          const payload = JSON.stringify({ words, stats, logs }, null, 2);
          const resp = await gistCreateOrUpdate({
            token: config.gistToken,
            gistId: undefined,
            filename: config.filename,
            content: payload,
          });
          setConfig(prev => ({ ...prev, gistId: resp.id }));
          alert("새 Gist를 생성했습니다.");
        } catch (e) {
          alert(e.message);
        }
      };

      return (
        <div className="min-h-screen w-full bg-gray-50 text-gray-900">
          <header className="sticky top-0 z-10 bg-white border-b border-gray-200">
            <div className="mx-auto max-w-md px-4 py-3 flex items-center justify-between">
              <h1 className="text-lg font-bold">단어카드</h1>
              <nav className="flex gap-2 text-sm">
                <button onClick={() => setTab("study")} className={`px-3 py-1 rounded-full border ${tab==='study'?'bg-gray-900 text-white border-gray-900':'bg-white text-gray-700 border-gray-300'}`}>학습</button>
                <button onClick={() => setTab("words")} className={`px-3 py-1 rounded-full border ${tab==='words'?'bg-gray-900 text-white border-gray-900':'bg-white text-gray-700 border-gray-300'}`}>단어</button>
                <button onClick={() => setTab("stats")} className={`px-3 py-1 rounded-full border ${tab==='stats'?'bg-gray-900 text-white border-gray-900':'bg-white text-gray-700 border-gray-300'}`}>통계</button>
                <button onClick={() => setTab("settings")} className={`px-3 py-1 rounded-full border ${tab==='settings'?'bg-gray-900 text-white border-gray-900':'bg-white text-gray-700 border-gray-300'}`}>설정</button>
              </nav>
            </div>
          </header>

          <main className="mx-auto max-w-md px-4 pb-28 pt-4">
            {tab === "study" && (
              <section>
                {/* Mode Switch */}
                <div className="mb-3 grid grid-cols-2 gap-2">
                  <button onClick={()=>setMode("ja2ko")} className={`rounded-xl border px-3 py-2 ${mode==='ja2ko'?'bg-gray-900 text-white border-gray-900':'bg-white text-gray-800 border-gray-300'}`}>🇯🇵 → 🇰🇷 일본어 → 뜻</button>
                  <button onClick={()=>setMode("ko2ja")} className={`rounded-xl border px-3 py-2 ${mode==='ko2ja'?'bg-gray-900 text-white border-gray-900':'bg-white text-gray-800 border-gray-300'}`}>🇰🇷 → 🇯🇵 뜻 → 일본어</button>
                </div>

                {!session.active && (
                  <div className="space-y-4">
                    <div className="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
                      <h2 className="text-base font-semibold">빠른 30개 세트</h2>
                      <p className="text-sm text-gray-600 mt-1">모르는 단어가 더 자주, 아는 단어도 가끔 등장합니다.</p>
                      <div className="mt-3 flex gap-2">
                        <button onClick={startSession} className="flex-1 rounded-xl bg-gray-900 text-white py-3 font-semibold">세트 시작</button>
                        <button onClick={() => setTab("words")} className="rounded-xl bg-white text-gray-900 py-3 px-4 border border-gray-300">단어 추가</button>
                      </div>
                    </div>

                    {words.length === 0 && (
                      <div className="rounded-2xl border border-dashed border-gray-300 bg-white p-4 text-sm text-gray-700">
                        먼저 단어를 추가하세요. 예시 입력(한 줄에 "일본어,한글"):
                        <pre className="mt-2 bg-gray-50 p-2 rounded">食べる,먹다{"\n"}美しい,아름답다{"\n"}速い,빠르다</pre>
                      </div>
                    )}

                    {words.length > 0 && (
                      <div className="text-xs text-gray-600">등록 단어 {words.length}개 · 전체 정확도 {accuracyTotal}% · 🇯🇵→🇰🇷 {accuracyJa2Ko}% · 🇰🇷→🇯🇵 {accuracyKo2Ja}%</div>
                    )}
                  </div>
                )}

                {session.active && !finishSession && current && (
                  <div className="space-y-4">
                    <div className="flex items-center justify-between text-sm text-gray-600">
                      <span>진행 {session.index + 1} / {session.queue.length}</span>
                      <button onClick={() => setSession({ active: false, queue: [], index: 0, results: [] })} className="underline">세트 중단</button>
                    </div>

                    <div className="rounded-3xl bg-white border border-gray-200 shadow-sm p-6 text-center select-none">
                      {mode === "ja2ko" ? (
                        <div className="text-2xl font-bold tracking-wide flex items-center justify-center gap-2">
                          <span>{current.jp}</span>
                          <button className="text-sm px-2 py-1 rounded-full border border-gray-300 bg-white icon-btn" title="발음 듣기" onClick={() => speakJa(current.jp)}>🔊</button>
                        </div>
                      ) : (
                        <div className="text-2xl font-bold tracking-wide">{current.ko}</div>
                      )}
                      <div className="mt-6">
                        {!showBack ? (
                          <button onClick={() => setShowBack(true)} className="w-full rounded-xl border border-gray-300 bg-gray-50 py-3">정답 보기</button>
                        ) : (
                          <div className="text-lg text-gray-900 font-medium flex items-center justify-center gap-2">
                            {mode === "ja2ko" ? current.ko : (<><span>{current.jp}</span><button className="text-sm px-2 py-1 rounded-full border border-gray-300 bg-white icon-btn" title="발음 듣기" onClick={() => speakJa(current.jp)}>🔊</button></>)}
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="grid grid-cols-2 gap-3">
                      <button onClick={() => recordAnswer(false)} className="rounded-2xl bg-white border-2 border-red-400 py-3 font-semibold">몰랐음</button>
                      <button onClick={() => recordAnswer(true)} className="rounded-2xl bg-white border-2 border-green-500 py-3 font-semibold">알았음</button>
                    </div>
                  </div>
                )}

                {finishSession && (
                  <div className="space-y-4">
                    <div className="rounded-2xl bg-white border border-gray-200 p-5 shadow-sm">
                      {(() => {
                        const total = session.results.length;
                        const correct = session.results.filter(r => r.correct).length;
                        const rate = total ? Math.round((correct/total)*100) : 0;
                        return (
                          <>
                            <h2 className="text-base font-semibold">세트 결과 ({mode === "ja2ko" ? "🇯🇵→🇰🇷" : "🇰🇷→🇯🇵"})</h2>
                            <div className="mt-2 text-sm text-gray-700">정답률 <span className="font-bold text-gray-900">{rate}%</span> ({correct}/{total})</div>
                          </>
                        );
                      })()}
                      <div className="mt-3 flex gap-2">
                        <button onClick={startSession} className="flex-1 rounded-xl bg-gray-900 text-white py-3 font-semibold">새 세트 시작</button>
                        <button onClick={restartWithMissed} className="flex-1 rounded-xl bg-white border border-gray-300 py-3 font-semibold">모르는 단어만</button>
                      </div>
                    </div>

                    <div className="rounded-2xl bg-white border border-gray-200 p-5 shadow-sm">
                      <h3 className="text-sm font-semibold">이번 세트에서 모른 항목</h3>
                      {Array.from(missedWords).length === 0 ? (
                        <p className="mt-2 text-sm text-gray-600">모든 항목을 맞혔습니다. 훌륭합니다!</p>
                      ) : (
                        <ul className="mt-2 text-sm list-disc list-inside space-y-1">
                          {missedWords.map(w => (
                            <li key={w.id}><span className="font-medium">{mode==="ja2ko"?w.jp:w.ko}</span> — {mode==="ja2ko"?w.ko:w.jp}</li>
                          ))}
                        </ul>
                      )}
                    </div>
                  </div>
                )}
              </section>
            )}

            {tab === "words" && (
              <section className="space-y-4">
                <div className="rounded-2xl bg-white border border-gray-200 p-4 shadow-sm">
                  <h2 className="text-base font-semibold">단어 추가</h2>
                  <div className="mt-3 grid grid-cols-1 gap-2">
                    <input value={jp} onChange={(e)=>setJp(e.target.value)} className="w-full rounded-xl border border-gray-300 px-3 py-3" placeholder="일본어 (例: 食べる)" />
                    <input value={ko} onChange={(e)=>setKo(e.target.value)} className="w-full rounded-xl border border-gray-300 px-3 py-3" placeholder="한글 뜻 (예: 먹다)" />
                    <div className="flex items-center gap-2">
                      <button onClick={addWord} className="flex-1 rounded-xl bg-gray-900 text-white py-3 font-semibold">추가</button>
                      {jp.trim() && (
                        <button type="button" onClick={() => speakJa(jp.trim())} className="px-3 py-3 rounded-xl border border-gray-300 bg-white icon-btn" title="입력 단어 발음">🔊</button>
                      )}
                    </div>
                  </div>
                </div>

                <div className="rounded-2xl bg-white border border-gray-200 p-4 shadow-sm">
                  <h3 className="text-sm font-semibold">대량 추가 (한 줄당 "일본어,한글")</h3>
                  <textarea ref={bulkRef} rows={5} className="mt-2 w-full rounded-xl border border-gray-300 px-3 py-3" placeholder={"食べる,먹다\n美しい,아름답다"} />
                  <div className="mt-2 flex gap-2">
                    <button onClick={addBulk} className="rounded-xl bg-white border border-gray-300 px-4 py-2">추가</button>
                    <button onClick={()=>{
                      const csv = words.map(w=>`${w.jp},${w.ko}`).join("\n");
                      navigator.clipboard.writeText(csv);
                      alert("CSV 형식으로 클립보드에 복사되었습니다.");
                    }} className="rounded-xl bg-white border border-gray-300 px-4 py-2">내보내기(클립보드)</button>
                    <button onClick={()=>{
                      const raw = prompt("붙여넣을 CSV 텍스트(일본어,한글)...");
                      if (!raw) return;
                      const lines = raw.split(/\n+/).map(l=>l.trim()).filter(Boolean);
                      const newItems = lines.map((line)=>{
                        const [j,k] = line.split(/[,\t|]/);
                        return { id: uid(), jp: (j||"").trim(), ko: (k||"").trim(), addedAt: Date.now(), timesSeen:0, timesKnown:0, timesUnknown:0, lastSeen:null, streakKnown:0 };
                      }).filter(w=>w.jp && w.ko);
                      if (newItems.length) setWords(prev=>[...newItems, ...prev]);
                    }} className="rounded-xl bg-white border border-gray-300 px-4 py-2">가져오기(텍스트)</button>
                  </div>
                </div>

                <div className="rounded-2xl bg-white border border-gray-200 p-4 shadow-sm">
                  <h3 className="text-sm font-semibold">단어 목록 ({words.length}개)</h3>
                  {words.length===0 ? (
                    <p className="mt-2 text-sm text-gray-600">등록된 단어가 없습니다.</p>
                  ) : (
                    <ul className="mt-2 divide-y divide-gray-100">
                      {words.map((w)=>{
                        const seen = w.timesSeen || 0;
                        const acc = seen ? Math.round((w.timesKnown/seen)*100) : 0;
                        return (
                          <li key={w.id} className="py-3 flex items-center justify-between gap-3">
                            <div>
                              <div className="text-sm font-medium flex items-center gap-2">
                                <span>{w.jp}</span>
                                <button className="text-xs px-2 py-1 rounded-full border border-gray-300 bg-white icon-btn" title="발음 듣기" onClick={() => speakJa(w.jp)}>🔊</button>
                                <span className="text-gray-500">— {w.ko}</span>
                              </div>
                              <div className="text-xs text-gray-500">학습 {seen} · 정답률 {acc}%</div>
                            </div>
                            <button onClick={()=>removeWord(w.id)} className="text-xs px-3 py-1 rounded-full border border-gray-300">삭제</button>
                          </li>
                        )
                      })}
                    </ul>
                  )}
                </div>
              </section>
            )}

            {tab === "stats" && (
              <section className="space-y-4">
                <div className="rounded-2xl bg-white border border-gray-200 p-4 shadow-sm">
                  <h2 className="text-base font-semibold">전체 통계</h2>
                  <div className="mt-2 grid grid-cols-2 gap-3 text-sm">
                    <Stat label="누적 세트" value={stats.sessions} />
                    <Stat label="누적 카드" value={stats.reviews} />
                    <Stat label="누적 정답" value={stats.correct} />
                    <Stat label="누적 오답" value={stats.incorrect} />
                  </div>
                  <div className="mt-3 text-sm">전체 정답률: <span className="font-semibold">{accuracyTotal}%</span></div>
                </div>

                <div className="rounded-2xl bg-white border border-gray-200 p-4 shadow-sm">
                  <h3 className="text-sm font-semibold">모드별 정답률</h3>
                  <div className="mt-2 grid grid-cols-2 gap-3 text-sm">
                    <Stat label="🇯🇵→🇰🇷" value={`${accuracyJa2Ko}%`} />
                    <Stat label="🇰🇷→🇯🇵" value={`${accuracyKo2Ja}%`} />
                  </div>
                </div>

                <div className="rounded-2xl bg-white border border-gray-200 p-4 shadow-sm">
                  <h3 className="text-sm font-semibold">세트 기록</h3>
                  {logs.length === 0 ? (
                    <p className="mt-2 text-sm text-gray-600">기록이 없습니다.</p>
                  ) : (
                    <ul className="mt-2 space-y-2 text-sm">
                      {[...logs].slice(-50).reverse().map((g) => {
                        const d = new Date(g.ts);
                        const label = `${d.getFullYear()}.${String(d.getMonth()+1).padStart(2,'0')}.${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
                        const rate = g.total ? Math.round(g.correct / g.total * 100) : 0;
                        return (
                          <li key={g.id} className="rounded-xl border border-gray-200 p-3">
                            <div className="flex items-center justify_between">
                              <div className="font-medium">{g.mode==="ja2ko"?"🇯🇵→🇰🇷":"🇰🇷→🇯🇵"} · {label}</div>
                              <div className="text-sm">{rate}% ({g.correct}/{g.total})</div>
                            </div>
                          </li>
                        );
                      })}
                    </ul>
                  )}
                </div>
              </section>
            )}

            {tab === "settings" && (
              <section className="space-y-4">
                <div className="rounded-2xl bg-white border border-gray-200 p-4 shadow-sm">
                  <h2 className="text-base font-semibold">클라우드 동기화 (GitHub Gist)</h2>
                  <p className="text-sm text-gray-600 mt-1">
                    - 개인 액세스 토큰(PAT)은 <b>gist</b> 권한만 주는 것을 권장합니다. 이 토큰은 이 기기의 LocalStorage에만 저장됩니다.<br/>
                    - 새 기기에서 동일한 <b>Gist ID</b>와 토큰을 입력한 뒤 "불러오기" 하면 단어/통계/기록을 모두 가져옵니다.
                  </p>
                  <div className="mt-3 grid gap-2 text-sm">
                    <label className="grid gap-1">
                      <span className="text-gray-600">GitHub Personal Access Token (gist scope)</span>
                      <input type="password" value={config.gistToken||""} onChange={e=>setConfig(prev=>({...prev, gistToken:e.target.value}))} className="w-full rounded-xl border border-gray-300 px-3 py-2" placeholder="ghp_..." />
                    </label>
                    <label className="grid gap-1">
                      <span className="text-gray-600">Gist ID</span>
                      <input value={config.gistId||""} onChange={e=>setConfig(prev=>({...prev, gistId:e.target.value}))} className="w-full rounded-xl border border-gray-300 px-3 py-2" placeholder="예: a1b2c3d4..." />
                    </label>
                    <label className="grid gap-1">
                      <span className="text-gray-600">파일명</span>
                      <input value={config.filename||"vocab_data.json"} onChange={e=>setConfig(prev=>({...prev, filename:e.target.value||"vocab_data.json"}))} className="w-full rounded-xl border border-gray-300 px-3 py-2" />
                    </label>
                    <div className="flex items-center gap-2 mt-1">
                      <input id="autosync" type="checkbox" checked={!!config.autoSync} onChange={e=>setConfig(prev=>({...prev, autoSync:e.target.checked}))} />
                      <label htmlFor="autosync" className="text-gray-700">자동 동기화(단어/통계/기록을 Gist에 자동 저장)</label>
                    </div>
                  </div>
                  <div className="mt-3 flex gap-2">
                    <button onClick={createNewGist} className="rounded-xl bg-white border border-gray-300 px-4 py-2">새 Gist 생성</button>
                    <button onClick={saveToGist} className="rounded-xl bg-white border border-gray-300 px-4 py-2">지금 저장</button>
                    <button onClick={loadFromGist} className="rounded-xl bg-white border border-gray-300 px-4 py-2">불러오기</button>
                  </div>
                </div>

                <div className="rounded-2xl bg-white border border-gray-200 p-4 shadow-sm">
                  <h3 className="text-sm font-semibold">백업/복원 (파일)</h3>
                  <div className="mt-2 flex gap-2">
                    <button onClick={()=>{
                      const payload = { words, stats, logs };
                      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement('a');
                      a.href = url;
                      a.download = `vocab_backup_${new Date().toISOString().slice(0,10)}.json`;
                      a.click();
                      URL.revokeObjectURL(url);
                    }} className="rounded-xl bg-white border border-gray-300 px-4 py-2">백업 다운로드</button>
                    <button onClick={()=>{
                      const input = document.createElement('input');
                      input.type = 'file';
                      input.accept = 'application/json';
                      input.onchange = () => {
                        const file = input.files && input.files[0];
                        if (!file) return;
                        const reader = new FileReader();
                        reader.onload = () => {
                          try {
                            const data = JSON.parse(String(reader.result || '{}'));
                            if (data.words && Array.isArray(data.words)) setWords(data.words);
                            if (data.stats) setStats(data.stats);
                            if (Array.isArray(data.logs)) setLogs(data.logs);
                            alert('복원 완료');
                          } catch (err) {
                            alert('복원 실패: 파일 형식 오류');
                          }
                        };
                        reader.readAsText(file);
                      };
                      input.click();
                    }} className="rounded-xl bg-white border border-gray-300 px-4 py-2">백업 복원</button>
                  </div>
                </div>
              </section>
            )}
          </main>

          <footer className="fixed bottom-0 left-0 right-0 mx-auto max-w-md px-4 py-3 bg-gradient-to-t from-white to-white/70 border-t border-gray-200">
            <div className="text-center text-[11px] text-gray-500">학습 데이터는 LocalStorage에 저장되며, 설정에서 Gist 동기화를 켜면 단어/정답률/세트 기록이 JSON으로 동기화됩니다.</div>
          </footer>
        </div>
      );
    }

    function Stat({ label, value }) {
      return (
        <div className="rounded-xl bg-gray-50 border border-gray-200 px-3 py-3 text-center">
          <div className="text-xs text-gray-500">{label}</div>
          <div className="text-lg font-bold">{value}</div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
